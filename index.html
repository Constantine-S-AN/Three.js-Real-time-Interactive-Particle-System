<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç²’å­æ‰‹åŠ¿äº¤äº’ç³»ç»Ÿ</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        canvas { display: block; }
        #webcam-feed {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            z-index: 10;
            opacity: 0.8;
            transition: opacity 0.3s;
        }
        #webcam-feed:hover { opacity: 1; }
        
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡å’ŒUIç»†èŠ‚ */
        .glass-panel {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .shape-btn.active {
            background-color: rgba(99, 102, 241, 0.8); /* Indigo-500 */
            border-color: rgba(129, 140, 248, 1);
            color: white;
        }

        #loading-screen {
            position: fixed;
            inset: 0;
            background: #000;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
        }
        
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: transparent;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }

        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <span class="loader mb-4"></span>
        <h2 id="loading-title" class="text-xl font-light tracking-widest text-gray-300">åˆå§‹åŒ–è§†è§‰ç³»ç»Ÿ...</h2>
        <p id="loading-note" class="text-xs text-gray-500 mt-2">é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ</p>
    </div>

    <!-- Webcam Video (Hidden from main view, shown in mini view) -->
    <video id="input-video" style="display:none"></video>
    <canvas id="webcam-feed"></canvas>

    <!-- Main 3D Canvas Container -->
    <div id="canvas-container" class="absolute inset-0 z-0"></div>

    <!-- UI Overlay -->
    <div class="absolute top-0 left-0 p-6 z-20 w-full md:w-80 flex flex-col gap-4 pointer-events-none">
        
        <!-- Controls Panel -->
        <div class="glass-panel rounded-2xl p-5 pointer-events-auto shadow-2xl transition-all hover:bg-opacity-80">
            <div class="flex items-start justify-between gap-2 mb-1">
                <div>
                    <h1 id="title-text" class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500">ç²’å­å¹»å¢ƒ</h1>
                    <p id="subtitle-text" class="text-xs text-gray-400">é€šè¿‡æ‰‹åŠ¿å¼ åˆæ§åˆ¶ç²’å­</p>
                </div>
                <select id="lang-select" class="bg-gray-900 border border-gray-700 text-xs rounded px-2 py-1 cursor-pointer">
                    <option value="zh">ä¸­æ–‡</option>
                    <option value="en">English</option>
                </select>
            </div>

            <!-- Shape Selection -->
            <div class="mb-4">
                <label id="shape-label" class="text-xs font-semibold text-gray-300 uppercase tracking-wider mb-2 block">æ¨¡å‹é€‰æ‹©</label>
                <div class="grid grid-cols-3 gap-2">
                    <button data-shape="heart" onclick="setShape('heart', this)" class="shape-btn active p-2 text-xs rounded border border-gray-700 bg-gray-800 hover:bg-gray-700 transition">â¤ï¸ çˆ±å¿ƒ</button>
                    <button data-shape="flower" onclick="setShape('flower', this)" class="shape-btn p-2 text-xs rounded border border-gray-700 bg-gray-800 hover:bg-gray-700 transition">ğŸŒ¸ èŠ±æœµ</button>
                    <button data-shape="saturn" onclick="setShape('saturn', this)" class="shape-btn p-2 text-xs rounded border border-gray-700 bg-gray-800 hover:bg-gray-700 transition">ğŸª åœŸæ˜Ÿ</button>
                    <button data-shape="buddha" onclick="setShape('buddha', this)" class="shape-btn p-2 text-xs rounded border border-gray-700 bg-gray-800 hover:bg-gray-700 transition">ğŸ§˜ ç¦…åƒ</button>
                    <button data-shape="fireworks" onclick="setShape('fireworks', this)" class="shape-btn p-2 text-xs rounded border border-gray-700 bg-gray-800 hover:bg-gray-700 transition">ğŸ† çƒŸèŠ±</button>
                    <button data-shape="sphere" onclick="setShape('sphere', this)" class="shape-btn p-2 text-xs rounded border border-gray-700 bg-gray-800 hover:bg-gray-700 transition">ğŸ”® çƒä½“</button>
                </div>
            </div>

            <!-- Color Picker -->
            <div class="mb-4 flex items-center justify-between">
                <label id="color-label" class="text-xs font-semibold text-gray-300 uppercase tracking-wider">ç²’å­é¢œè‰²</label>
                <div class="flex items-center gap-2">
                    <input type="color" id="color-picker" value="#4f46e5" class="w-8 h-8 rounded cursor-pointer border-0 bg-transparent p-0">
                    <span id="color-val" class="text-xs text-gray-400 font-mono">#4F46E5</span>
                </div>
            </div>

            <!-- Status Indicator -->
            <div class="border-t border-gray-700 pt-3 mt-2">
                <div class="flex items-center justify-between">
                    <span id="gesture-label" class="text-xs text-gray-400">æ‰‹åŠ¿çŠ¶æ€:</span>
                    <span id="gesture-status" class="text-xs font-bold text-yellow-400">ç­‰å¾…æ£€æµ‹...</span>
                </div>
                <div class="w-full bg-gray-700 h-1.5 rounded-full mt-2 overflow-hidden">
                    <div id="pinch-meter" class="bg-blue-500 h-full w-0 transition-all duration-100"></div>
                </div>
            </div>
        </div>

        <!-- Fullscreen Button -->
        <button onclick="toggleFullScreen()" class="glass-panel p-3 rounded-xl pointer-events-auto hover:bg-white hover:text-black transition flex items-center justify-center gap-2 w-full md:w-auto self-start">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 4l-5-5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
            </svg>
            <span id="fullscreen-label" class="text-sm font-medium">å…¨å±æ¨¡å¼</span>
        </button>
    </div>

    <script>
        // --- 1. é…ç½®ä¸å…¨å±€å˜é‡ ---
        const PARTICLE_COUNT = 18000;
        const PARTICLE_SIZE = 0.15;
        const INITIAL_COLOR = 0x4f46e5;
        const i18n = {
            zh: {
                title: 'ç²’å­å¹»å¢ƒ',
                subtitle: 'é€šè¿‡æ‰‹åŠ¿å¼ åˆæ§åˆ¶ç²’å­',
                shapeLabel: 'æ¨¡å‹é€‰æ‹©',
                colorLabel: 'ç²’å­é¢œè‰²',
                gestureLabel: 'æ‰‹åŠ¿çŠ¶æ€:',
                fullscreen: 'å…¨å±æ¨¡å¼',
                loadingTitle: 'åˆå§‹åŒ–è§†è§‰ç³»ç»Ÿ...',
                loadingNote: 'é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ ç§’é’Ÿ',
                shapes: {
                    heart: 'â¤ï¸ çˆ±å¿ƒ',
                    flower: 'ğŸŒ¸ èŠ±æœµ',
                    saturn: 'ğŸª åœŸæ˜Ÿ',
                    buddha: 'ğŸ§˜ ç¦…åƒ',
                    fireworks: 'ğŸ† çƒŸèŠ±',
                    sphere: 'ğŸ”® çƒä½“'
                },
                status: {
                    waiting: 'ç­‰å¾…æ£€æµ‹...',
                    pinch: 'æåˆ (æ”¶ç¼©)',
                    open: 'å¼ å¼€ (æ‰©æ•£)',
                    controlling: 'æ§åˆ¶ä¸­...',
                    none: 'æœªæ£€æµ‹åˆ°æ‰‹åŠ¿'
                }
            },
            en: {
                title: 'Particle Mirage',
                subtitle: 'Control particles by pinching and opening your hand',
                shapeLabel: 'Shape Selection',
                colorLabel: 'Particle Color',
                gestureLabel: 'Gesture Status:',
                fullscreen: 'Fullscreen',
                loadingTitle: 'Initializing vision system...',
                loadingNote: 'First load may take a few seconds',
                shapes: {
                    heart: 'â¤ï¸ Heart',
                    flower: 'ğŸŒ¸ Flower',
                    saturn: 'ğŸª Saturn',
                    buddha: 'ğŸ§˜ Zen',
                    fireworks: 'ğŸ† Fireworks',
                    sphere: 'ğŸ”® Sphere'
                },
                status: {
                    waiting: 'Waiting...',
                    pinch: 'Pinch (Contract)',
                    open: 'Open (Expand)',
                    controlling: 'In control...',
                    none: 'No hand detected'
                }
            }
        };
        
        let scene, camera, renderer, particles, geometry, material;
        let targetPositions = []; // ç›®æ ‡å½¢çŠ¶çš„åæ ‡æ•°ç»„
        let currentPositions = []; // å½“å‰ç²’å­çš„åæ ‡æ•°ç»„
        let velocities = []; // ç®€å•çš„è¿åŠ¨é€Ÿåº¦
        let animationId;
        
        // äº¤äº’çŠ¶æ€
        let handExpansionFactor = 0; // 0 = é—­åˆ/åŸå§‹å½¢çŠ¶, 1 = å®Œå…¨å¼ å¼€/çˆ†ç‚¸
        let targetExpansion = 0; // ç”¨äºå¹³æ»‘è¿‡æ¸¡
        let isHandDetected = false;
        let currentShape = 'heart';
        let currentLanguage = 'zh';

        // --- 2. å½¢çŠ¶ç”Ÿæˆæ•°å­¦é€»è¾‘ ---
        
        function getShapePosition(type, i) {
            const idx = i;
            const u = Math.random();
            const v = Math.random();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            let x, y, z;

            switch (type) {
                case 'heart':
                    // å‚æ•°åŒ–å¿ƒå½¢æ–¹ç¨‹
                    // x = 16sin^3(t)
                    // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                    const t = theta;
                    // ä¸ºäº†å¡«å……ä½“ç§¯ï¼Œä½¿ç”¨æŸç§åˆ†å¸ƒ
                    const rHeart = Math.cbrt(u) * 15; // ç¼©æ”¾å› å­
                    // 3D å˜ä½“
                    x = rHeart * (16 * Math.pow(Math.sin(t), 3));
                    y = rHeart * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    z = (Math.random() - 0.5) * 10 * rHeart; // å¢åŠ ä¸€äº›åšåº¦
                    // å½’ä¸€åŒ–å¹¶ç¼©å°
                    x *= 0.02; y *= 0.02; z *= 0.02;
                    y += 1; // ä¸Šç§»ä¸€ç‚¹
                    break;

                case 'flower':
                    // ç«ç‘°æ›²çº¿/èºæ—‹
                    const rFlower = Math.sqrt(u) * 5;
                    const angle = idx * 137.5 * (Math.PI / 180); // é»„é‡‘è§’
                    const k = 4; // èŠ±ç“£æ•°å‚æ•°
                    const petal = Math.cos(k * angle);
                    x = rFlower * Math.cos(angle) * (1 + 0.5 * petal);
                    z = rFlower * Math.sin(angle) * (1 + 0.5 * petal);
                    y = Math.sin(rFlower) * 2 - (rFlower * 0.3);
                    // ç¼©å°
                    x *= 0.6; y *= 0.6; z *= 0.6;
                    break;

                case 'saturn':
                    // çƒä½“ + ç¯
                    if (i < PARTICLE_COUNT * 0.4) {
                        // æ˜Ÿçƒä¸»ä½“ (40% ç²’å­)
                        const rPlanet = 2.5 * Math.cbrt(Math.random());
                        x = rPlanet * Math.sin(phi) * Math.cos(theta);
                        y = rPlanet * Math.sin(phi) * Math.sin(theta);
                        z = rPlanet * Math.cos(phi);
                    } else {
                        // ç¯ (60% ç²’å­)
                        const rRing = 3.5 + Math.random() * 2.5;
                        x = rRing * Math.cos(theta);
                        z = rRing * Math.sin(theta);
                        y = (Math.random() - 0.5) * 0.2; // ç¯éå¸¸è–„
                        
                        // ç¨å¾®å€¾æ–œç¯
                        const tilt = Math.PI / 6;
                        const tempY = y * Math.cos(tilt) - z * Math.sin(tilt);
                        const tempZ = y * Math.sin(tilt) + z * Math.cos(tilt);
                        y = tempY;
                        z = tempZ;
                    }
                    break;

                case 'buddha':
                    // æŠ½è±¡ç¦…åƒï¼šåº•éƒ¨å®½åŸºåº§ï¼ˆç›˜è…¿ï¼‰+ ä¸­é—´èº¯å¹² + é¡¶éƒ¨å¤´éƒ¨
                    if (i < PARTICLE_COUNT * 0.5) {
                        // åŸºåº§ (è…¿éƒ¨) - æ‰æ¤­çƒ
                        const rBase = 3 * Math.sqrt(Math.random());
                        const hBase = Math.random() * 1.5;
                        x = rBase * Math.cos(theta);
                        z = rBase * Math.sin(theta);
                        y = hBase - 3;
                    } else if (i < PARTICLE_COUNT * 0.85) {
                        // èº¯å¹² - åœ†é”¥/åœ†æŸ±
                        const rBody = 1.8 * Math.random();
                        const hBody = Math.random() * 2.5;
                        x = rBody * Math.cos(theta);
                        z = rBody * Math.sin(theta);
                        y = hBody - 1.5;
                    } else {
                        // å¤´éƒ¨ - çƒä½“
                        const rHead = 0.9 * Math.cbrt(Math.random());
                        x = rHead * Math.sin(phi) * Math.cos(theta);
                        y = rHead * Math.sin(phi) * Math.sin(theta) + 1.8;
                        z = rHead * Math.cos(phi);
                    }
                    break;
                
                case 'fireworks':
                    // éšæœºçƒä½“çˆ†ç‚¸èµ·å§‹ç‚¹ (ä¸ºäº†å±•ç¤ºæ•ˆæœï¼Œè¿™é‡Œè®¾ä¸ºçƒä½“ï¼Œå¼ å¼€æ‰‹æ—¶ä¼šå‰§çƒˆç‚¸å¼€)
                    const rFire = 0.2 + Math.random() * 0.5;
                    x = rFire * Math.sin(phi) * Math.cos(theta);
                    y = rFire * Math.sin(phi) * Math.sin(theta);
                    z = rFire * Math.cos(phi);
                    break;

                case 'sphere':
                default:
                    const r = 3 * Math.cbrt(Math.random());
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                    break;
            }
            return { x, y, z };
        }

        function generateTargetPositions(shapeType) {
            const arr = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const pos = getShapePosition(shapeType, i);
                arr[i * 3] = pos.x;
                arr[i * 3 + 1] = pos.y;
                arr[i * 3 + 2] = pos.z;
            }
            return arr;
        }

        // --- 3. Three.js åˆå§‹åŒ– ---

        function initThree() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            // æ·»åŠ ä¸€ç‚¹è¿·é›¾å¢å¼ºæ·±åº¦æ„Ÿ
            scene.fog = new THREE.FogExp2(0x050505, 0.03);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);

            // åˆå§‹åŒ–ç²’å­
            geometry = new THREE.BufferGeometry();
            const initialPos = new Float32Array(PARTICLE_COUNT * 3);
            
            // åˆå§‹éšæœºä½ç½®
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                initialPos[i] = (Math.random() - 0.5) * 20;
                currentPositions[i] = initialPos[i];
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(initialPos, 3));

            // ç”Ÿæˆç›®æ ‡ä½ç½®
            targetPositions = generateTargetPositions(currentShape);

            // æè´¨
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            material = new THREE.PointsMaterial({
                color: INITIAL_COLOR,
                size: PARTICLE_SIZE,
                map: sprite,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // ç¯å…‰ (è™½ç„¶ä¸»è¦é è‡ªå‘å…‰æè´¨ï¼Œä½†åŠ ä¸ªå…‰å¢åŠ ä¸€ç‚¹ç«‹ä½“æ„Ÿå¦‚æœä»¥åç”¨Mesh)
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);

            window.addEventListener('resize', onWindowResize, false);
            
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 4. åŠ¨ç”»å¾ªç¯ä¸ç‰©ç†é€»è¾‘ ---

        function animate() {
            animationId = requestAnimationFrame(animate);

            const positions = particles.geometry.attributes.position.array;
            const time = Date.now() * 0.001;

            // å¹³æ»‘æ‰‹åŠ¿è¾“å…¥
            targetExpansion = THREE.MathUtils.lerp(targetExpansion, handExpansionFactor, 0.1);

            // ç²’å­è¿åŠ¨é€»è¾‘
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // ç›®æ ‡åŸºç¡€ä½ç½®
                const tx = targetPositions[i3];
                const ty = targetPositions[i3 + 1];
                const tz = targetPositions[i3 + 2];

                // è®¡ç®—æ‰©æ•£æ•ˆæœ
                // å¦‚æœå¼ æ‰‹ (expansion > 0.5)ï¼Œç²’å­å‘å¤–é£æ•£
                // å¦‚æœæåˆ (expansion < 0.2)ï¼Œç²’å­ç´§å‡‘
                // ä¸­é—´å€¼åˆ™ä¿æŒåœ¨ç›®æ ‡å½¢çŠ¶é™„è¿‘ç¨å¾®æµ®åŠ¨
                
                let scale = 1 + targetExpansion * 3; // å¼ æ‰‹æ—¶æ”¾å¤§3å€
                if (currentShape === 'fireworks' && targetExpansion > 0.6) {
                    scale = 1 + targetExpansion * 8; // çƒŸèŠ±ç‚¸å¾—æ›´è¿œ
                }

                // å™ªç‚¹/å‘¼å¸æ•ˆæœ
                const noise = Math.sin(time * 2 + i) * 0.1 * (1 - targetExpansion); 

                // ç›®æ ‡ä½ç½® + æ‰©æ•£ logic
                let targetX = tx * scale + noise;
                let targetY = ty * scale + noise;
                let targetZ = tz * scale + noise;

                // ç®€å•çš„ Lerp æ’å€¼ç§»åŠ¨ç²’å­
                // é€Ÿåº¦å–å†³äºå¼ å¼€ç¨‹åº¦ï¼Œå¼ å¼€è¶Šå¿«ï¼Œç§»åŠ¨è¶Šå‰§çƒˆ
                const lerpSpeed = 0.03 + (targetExpansion * 0.05);

                currentPositions[i3] += (targetX - currentPositions[i3]) * lerpSpeed;
                currentPositions[i3+1] += (targetY - currentPositions[i3+1]) * lerpSpeed;
                currentPositions[i3+2] += (targetZ - currentPositions[i3+2]) * lerpSpeed;

                positions[i3] = currentPositions[i3];
                positions[i3+1] = currentPositions[i3+1];
                positions[i3+2] = currentPositions[i3+2];
            }

            // æ•´ä½“æ—‹è½¬
            particles.rotation.y += 0.002;
            if (targetExpansion > 0.5) {
                particles.rotation.y += 0.01; // å¼ å¼€æ—¶æ—‹è½¬åŠ é€Ÿ
            }

            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        // --- 5. MediaPipe æ‰‹åŠ¿è¯†åˆ« ---

        const videoElement = document.getElementById('input-video');
        const canvasElement = document.getElementById('webcam-feed');
        const canvasCtx = canvasElement.getContext('2d');
        const statusEl = document.getElementById('gesture-status');
        const meterEl = document.getElementById('pinch-meter');

        function onResults(results) {
            // éšè—åŠ è½½å±‚
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => { document.getElementById('loading-screen').style.display = 'none'; }, 500);

            // ç»˜åˆ¶æ‘„åƒå¤´å°çª—å£
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // ç»˜åˆ¶éª¨æ¶
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 2});

                // è®¡ç®—æ‹‡æŒ‡(4)å’Œé£ŸæŒ‡(8)çš„è·ç¦»
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                
                // ç®€å•çš„æ¬§å‡ é‡Œå¾—è·ç¦» (2DæŠ•å½±è·ç¦»å³å¯æ»¡è¶³ç®€å•äº¤äº’)
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                
                // å½’ä¸€åŒ–è·ç¦»ï¼šé€šå¸¸æåˆæ—¶ < 0.05ï¼Œå¼ å¼€æ—¶ > 0.2 (å–å†³äºæ‘„åƒå¤´è·ç¦»)
                // æˆ‘ä»¬è®¾å®šä¸€ä¸ªèŒƒå›´ [0.03, 0.25] æ˜ å°„åˆ° [0, 1]
                let normalized = (distance - 0.03) / (0.25 - 0.03);
                normalized = Math.max(0, Math.min(1, normalized)); // Clamp 0-1

                handExpansionFactor = normalized;

                // UI æ›´æ–°
                if (normalized < 0.2) {
                    statusEl.innerText = i18n[currentLanguage].status.pinch;
                    statusEl.className = "text-xs font-bold text-blue-400";
                } else if (normalized > 0.7) {
                    statusEl.innerText = i18n[currentLanguage].status.open;
                    statusEl.className = "text-xs font-bold text-red-400";
                } else {
                    statusEl.innerText = i18n[currentLanguage].status.controlling;
                    statusEl.className = "text-xs font-bold text-yellow-400";
                }
                meterEl.style.width = `${normalized * 100}%`;

            } else {
                isHandDetected = false;
                statusEl.innerText = i18n[currentLanguage].status.none;
                statusEl.className = "text-xs font-bold text-gray-500";
                // å¦‚æœæ²¡æœ‰æ‰‹ï¼Œè‡ªåŠ¨æ¢å¤å¹³ç¼“å‘¼å¸çŠ¶æ€ï¼ˆè®¾ä¸º0æˆ–0.2ï¼‰
                handExpansionFactor = 0.1; 
                meterEl.style.width = '0%';
            }
            canvasCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });

        // --- 6. UI äº¤äº’é€»è¾‘ ---

        function setShape(shape, btn) {
            currentShape = shape;
            targetPositions = generateTargetPositions(shape);
            
            // æ›´æ–°æŒ‰é’®æ ·å¼
            document.querySelectorAll('.shape-btn').forEach(el => el.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        document.getElementById('color-picker').addEventListener('input', (e) => {
            const hex = e.target.value;
            document.getElementById('color-val').innerText = hex.toUpperCase();
            material.color.set(hex);
        });

        function toggleFullScreen() {
            const doc = window.document;
            const docEl = doc.documentElement;

            // å…¼å®¹æ€§å¤„ç†ï¼šæ”¯æŒæ ‡å‡†APIã€Webkit (Safari/Chrome)ã€Moz (Firefox)ã€MS (IE/Edge)
            const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
            const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;
            const isFullScreen = doc.fullscreenElement || doc.mozFullScreenElement || doc.webkitFullscreenElement || doc.msFullscreenElement;

            if (!isFullScreen) {
                if (requestFullScreen) {
                    requestFullScreen.call(docEl).catch(err => {
                        console.warn("å…¨å±è¯·æ±‚å¤±è´¥:", err);
                        alert("æ— æ³•è¿›å…¥å…¨å±æ¨¡å¼ï¼šå½“å‰æµè§ˆå™¨æˆ–è¿è¡Œç¯å¢ƒï¼ˆå¦‚iframeï¼‰å¯èƒ½é™åˆ¶äº†æ­¤æƒé™ã€‚");
                    });
                } else {
                    alert("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå…¨å±API");
                }
            } else {
                if (cancelFullScreen) {
                    cancelFullScreen.call(doc);
                }
            }
        }

        function applyLanguage(lang) {
            currentLanguage = lang;
            const copy = i18n[lang];
            document.getElementById('title-text').innerText = copy.title;
            document.getElementById('subtitle-text').innerText = copy.subtitle;
            document.getElementById('shape-label').innerText = copy.shapeLabel;
            document.getElementById('color-label').innerText = copy.colorLabel;
            document.getElementById('gesture-label').innerText = copy.gestureLabel;
            document.getElementById('fullscreen-label').innerText = copy.fullscreen;
            document.getElementById('loading-title').innerText = copy.loadingTitle;
            document.getElementById('loading-note').innerText = copy.loadingNote;
            document.getElementById('gesture-status').innerText = copy.status.waiting;
            document.querySelectorAll('.shape-btn').forEach(btn => {
                const key = btn.getAttribute('data-shape');
                btn.innerText = copy.shapes[key];
            });
        }

        // --- å¯åŠ¨ ---
        initThree();
        cameraUtils.start();

        // è°ƒæ•´å°çª—å£ç”»å¸ƒå¤§å°
        canvasElement.width = 320;
        canvasElement.height = 240;

        // è¯­è¨€åˆ‡æ¢
        document.getElementById('lang-select').addEventListener('change', (e) => {
            applyLanguage(e.target.value);
        });
        applyLanguage(currentLanguage);

    </script>
</body>
</html>
